# Coloured Triangles

## Problem Breif

A coloured triangle is created from a row of colours, each of which is red,
green or blue. Successive rows, each containing one fewer colour than the
last, are generated by considering the two touching colours in the previous
row. If these colours are identical, the same colour is used in the new row.
If they are different, the missing colour is used in the new row. This is
continued until the final row, with only a single colour, is generated.

The different possibilities are:

```
Colour here:            G G        B G        R G        B R
Becomes colour here:     G          R          B          G
```

With a bigger example:

```
R R G B R G B B
 R B R G B R B
  G G B R G G
   G R G B G
    B B R R
     B G R
      R B
       G
```

You will be given the first row of the triangle as a string and its your job
to return the final colour which would appear in the bottom row as a string.
In the case of the example above, you would the given RRGBRGBB you should
return G.

## Solution notes

### Version 1

- For n = 1,000, t = 15ms
- For n = 2,042, t = 61ms
- n*2 = t*4, O(n^2) time complexity as expected
- This is too slow
- n = 10,000 would take 1.5s
- n = 100,000 would take 150s = 2.5 minutes
- Profiling showed string concatenation and object property access as slow parts

### Version 2

- For n = 1,000, t = 3ms
- For n = 2,042, t = 12ms
- n*2 = t*4, O(n^2) time complexity still, but about 5x faster
- This is still too slow
- n = 10,000 would take 300ms
- n = 100,000 would take 30s

### Version 3

Apparently there is a O(n log n) solution, but the final solution is sub-linear.

Apparently there is a pattern visible in the smaller triangles that is a clue,
but I can't see it.

Possibly also some mod3 math involved, but that isn't obvious either. Or base 3?

Not all input letters influence the output?
Changing any one letter will definitely change the output.
But maybe there are pairs that can change together without changing the output?

You can change a letter, as long as you change the adjecent the opposite
way round to RGB cycle.
I wonder if we could just count the letters, rather the changing them?
Is it actually a parity algorithm?

So maybe break each triangle in to sub triangles?
But I don't get how this would be faster.

I cracked it!

n = 100,000 in about 20ms

I won't explain it to avoid spoiling it, but you should definately attempt it
yourself, very frustating then very satisfying.
